
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{courier}

\usepackage{euler}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 23-10-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Divisione}
Siano dati $X$, un naturale in base $\beta$ su $n+m$ cifre, detto \textbf{dividendo}, con $0 \leq X \leq \beta^{n+m}-1$,
e $Y$, un naturale in base $\beta$ su $m$ cifre, detto \textbf{divisore}, con $0 \leq Y \leq \beta^m -1$.
Vogliamo calcolare i due numeri $Q$ ed $R$ tali che:
$$ X = Q \cdot Y + R$$

Abbiamo che, con $|Y=0|$, la divisione non è fattibile, quindi avremo bisogno di un uscita di \textbf{non fattibilità} \lstinline|no_div|.

\subsubsection{Dimensioni di resti e quozienti}
Assumendo $Y > 0$, si ha che $Q$ sta su $n+m$ cifre (caso peggiore $Y = 1$), mentre $R$ sta su $m$ cifre, in quanto $0 \leq R \leq Y$ dalle proprietà della divisione.
Scelgo, per ragioni tecniche, che il quoziente dovrà stare su $n$ cifre, quindi impongo $Q \leq \beta^n -1$.
Nel caso non si possa rappresentare $Q$, quindi, userò sempre la stessa uscita \lstinline|no_div| di prima.

La decisione fatta riguardo a $Q$ implica che:
$$ 
X = Q \cdot Y + R \leq (\beta^n - 1) \cdot Y + (Y - 1) = \beta^n \cdot Y - 1 \Rightarrow X < \beta^n \cdot Y
$$

L'ipotesi potrebbe sembrare limitante, ma visto che si può ricavare $n$ che soddisfi la disuguaglianza, possiamo eseguire qualsiasi divisione poste \textbf{estensioni} del dividendo e \textbf{riserve} di cifre (cioè più delle strettamente necessarie) per il quoziente.

Nel caso il numero di cifre $n$, $m$ sia dato dal problema, cioè quando si lavora su \textbf{campi finiti}, l'ipotesi è restrittiva.

L'obiettivo è quello di progettare circuiti che eseguano questa divisione su campi di dimensioni prestabilite: dovremmo ricordare questa proprietà nello sviluppo e del circuito (e noteremo ha un significato specifico), e quando andiamo ad utilizzarlo, cioè quando si scrivono istruzioni assembly che ordinano divisioni fra numeri su registri di dimensione diversa.

\subsubsection{Modulo divisore}
Vogliamo quindi realizzare un circuito che:
\begin{enumerate}
	\item Verifichi la \textbf{fattibilità} della divisione nelle ipotesi date;
	\item Se il quoziente sta su $n$ cifre, lo restituisca, altrimenti restituisca \lstinline|no_div|.
\end{enumerate}

La divisione viene svolta, tradizionalmente, prendendo un sottoinsieme delle $n$ cifre più significative del dividendo, tali per cui possiamo trovare quante volta il divisore sta nel sottoinsieme.
Visto che non possiamo riscalare il numero di cifre prese dal divisore una volta assemblato il circuito, abbiamo bisogno di un numero minimo di cifre da prendere ogni volta, per essere sicuri di poter eseguire la divisione. 
Formalmente, quindi, prendo il minimo numero di cifre più significative di $X$ per ottenere un $X' \in [Y, \beta \cdot Y[$
In questo $m$ cifre possono non bastare (potremmo avere che le $m$ cifre più significative di $X$ sono $< Y$), mentre $m+1$ bastano sempre (purchè $X$ non abbia zeri in testa).

Si calcolano quindi i quozienti e i resti \textbf{parziali}, $q$ e $R'$, dalla divisione di $X'$ e $Y$.
Si ha che $q$ sta su una sola cifra, perchè $X' < \beta \cdot Y$ dall'ipotesi.

Calcolo quindi il nuovo dividendo $X'$ concatenando $R'$ con la cifra più significativa non ancora utilizzata di $X$.
Il nuovo dividendo, date le ipotesi, è ancora $< \beta \cdot Y$:
$$
R' \leq Y - 1, \quad \beta \cdot R' + (\beta - 1) \leq \beta \cdot  Y - \beta + \beta + 1 = \beta \cdot Y
$$

Si itera fino ad esaurimento delle cifre del dividendo.
A questo punto il \textbf{quoziente} è ottenuto dal concatenamento dei quozienti parziali, e il resto è l'ultimo resto parziale.

Abbiamo che l'unica divisione effettiva è quella di $m+1$ per $m$ cifre, mentre tutte le altre sono effettivamente scomposizioni, quindi circuiti di logica a costo nullo.
Resta quindi da calcolare solo il flag di non fattibilità \lstinline|no_div|: questo deriva naturalmente da quanto avevamo detto riguardo alle dimensioni del dividendo:
$$
X < \beta^n \cdot Y
$$

Inoltre, vogliamo impostare \lstinline|no_div| anche nel caso $Y$ sia nullo, per ovvi motivi.

\subsubsection{Divisione nei processori Intel x86}
Abbiamo visto come nei processori Intel x86, abbiamo a disposizione tre versioni della divisione:

\begin{table}[h!]
	\center \rowcolors{2}{white}{black!10}
	\begin{tabular} { c | c | c | c | c }
		\bfseries Dim. sorgente (divisore) & \bfseries Dim. dividendo & \bfseries Dividendo & \bfseries Quoziente & \bfseries Resto \\ 
		\hline 
		8 bit & 16 bit & AX & AL & AH \\ 
		16 bit & 32 bit & DX\_AX & AX & DX \\ 
		32 bit & 64 bit & EDX\_EAX & EAX & EDX
	\end{tabular}
\end{table}

Si ha che la \lstinline|DIV| ammette dividendo su $2n$ bit e divisore su $n$ bit, con $n = 8, \, 16, \, 32$, e richiede che il quoziente stia su $n$ bit (altrimenti genera un'eccezione).
Questo è quello che si otterrebbe ponendo $n = m$.

\subsubsection{Divisione elementare in base 2}
Resta quindi da capire come effettuare la divisione elementare fra un numero a $m+1$ cifre e un altro a $m$ cifre, sotto l'ipotesi $X \leq 2Y = 2^1 \cdot Y$ (siamo in $\beta=2$).

Abbiamo che $Q$ può valere 0 o 1. Vale 0 se il divisore $Y$ è maggiore del dividendo $X$, 1 altrimenti.
$R$, invece, è uguale al dividendo $X$ se questo è minore del divisore $Y$, altrimenti è uguale a $X - Y$:
$$
Q=
\begin{cases}
	0, \quad X < Y \\ 
	1, \quad X \geq Y
\end{cases}, \quad 
R =
\begin{cases}
	X, \quad X < Y \\ 
	X-Y, \quad X \geq Y
\end{cases}
$$

Per rappresentare questo sistema ci serve un comparatore fra $X$ e $Y$. 
Lo realizziamo con un sottrattore (di cui bisognavamo comunque per il calcolo di $X-Y$), quindi mandando $Y$ complementato (ed opportunamente esteso) al secondo input di un sommatore, ed $X$ al primo. 
Il sommatore ha $C_{in} = 0$.

Fuori dal sommatore, avremo $X-Y$ come risultato, e $b_{out}$ come discrimnante per $X < Y$.
Mandiamo quindi $X$ e $X-Y$ agli ingressi di un multiplexer con variabile di controllo $C_{out}$ dal sommatore,
cioè discriminiamo fra $X$ e $X-Y$ sulla base di quanto restituito dal comparatore.

A questo punto si ha che $b_{out}$ rappresenta $Q$, mentre l'uscita del multiplexer è $R$.



\end{document}
