\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{25-09-24}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}

\lstdefinelanguage{javascript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 25-09-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Introduzione all'Assembler}

\subsubsection{Codifica macchina e codifica mnemonica}
Possiamo adottare 2 metodi per codificare le istruzioni eseguite dal processore:

\begin{itemize}
	\item \textbf{Codifica macchina:} la serie di zeri e di uni che codificano, nel linguaggio del processore, le operazioni che esegue.
		Il formato macchina è, nell'architettura che ci interessa, il seguente:

		\begin{table}[h!]
			\center \rowcolors{2}{white}{black!10}
			\begin{tabular} { c | c | c }
				\bfseries Segmento & \bfseries Byte & \bfseries Funzione \\
				\hline 
				I Prefix (Instruction Prefix) & 0/1 byte & Usato per modificare l'istruzione \\ 
				O Prefix (Operand-size prefix) & 0/1 byte & Usato per modificare la dimensione degli operandi \\
				Opcode &
			\end{tabular}
		\end{table}

	\item \textbf{Codifica mnemonica:} un modo \textbf{simbolico} per riferirsi alle istruzioni.
		Un'istruzione può quindi essere semplicemente: \texttt{MOV \%EAX, 0x01F4E39}.
\end{itemize}

Il linguaggio assembler usa la codifica mnemonica delle istruzioni, e dispone di sovrastrutture sintattiche che lo rendono più comprensibile agli umani.
Ad esempio, permette l'uso di nomi simbolici per locazioni di memoria: \texttt{MOV \%EAX, pippo}.

\subsubsection{Istruzioni in codifica mnemonica}
Un'istruzione ha 3 campi:
\begin{itemize}
	\item \textbf{Codice operativo:} stabilisce quale operazione eseguire;
	\item \textbf{Suffisso di lunghezza:} stabilisce la lunghezza (che può variare) degli operandi;	
	\item \textbf{Operandi:} gli operandi su cui si applica l'operazione. 
		Possono essere contenuti in registri, in celle di memoria, nelle porte I/O o direttamente nell'istruzione (\textbf{costanti}).
\end{itemize}

Il suffisso di lunghezza può essere omesso quando è chiaro (essenzialmente quando si usa un registro).

Sintatticamente la struttura è \texttt{OPCODEsuffix source, dest}, che diventa qualcosa come \texttt{ADD \%BX, pluto}.
Questa istruzione effettua l'operazione \texttt{ADD} (aggiungi), aggiungendo al registro \texttt{BX} ciò che è contenuto nel simbolo \texttt{pluto}.

\par\medskip
\noindent
\textsf{\textbf{Operandi di istruzioni}} \\
Le istruzioni ammettono 0, 1 o 2 operandi.
Quando sono 2, il primo operando si chiama \textbf{sorgente} e il secondo \textbf{destinatario}, e solitamente hanno la stessa lunghezza.
Quando è 1, l'operando può essere sia sorgente che destinatario a seconda dell'istruzione.

\subsubsection{Primo esempio di programma}

Si presenta un programma per contare il numero di uno trovati dalla locazione \texttt{0x00000100} a \texttt{0x0000010i3}e scriverlo nella locazione \texttt{0x00000104}. 

\begin{lstlisting}[style=codestyle]	
MOVB $0x00, %CL					% sposta $0x00 in %CL
MOVL 0x00000100, %EAX		% sposta 32 bit da 0x00000100 a %EAX
CMPL $0x00000000, %EAX	% confronta 32 bit di 0 con il registro %EAX
JE   %EIP+$0x07					% salta se uguale a %EIP+$0x07, 
												%	ergo 0x0000020C + 0x07 = 0x00000213
SHRL %EAX								% trasla a destra %EAX
ADCB $0x00, %CL					% aggiungi a %CL 0 + carry 
JMP  %EIP-$0x0C					% salta incondizionato a %EIP-$0x0C,
												% ergo 0x00000213 - 0x0C = 0x00000207
MOVB %CL, 0x00000104		% sposta byte da %CL a 0x00000104
\end{lstlisting}

Il programma svolge i seguenti passi:
\begin{algorithm}
\caption{Conta 0}
\begin{algorithmic}
	\STATE Inizializza il registro CL (Counter Low) a 0
	\STATE Sposta i 32 bit da \texttt{0x00000000} a \texttt{0x00000103} in EAX
	\WHILE{true}	
		\IF{EAX è vuoto (tutti zeri)}
			\STATE Salta all'ultima istruzione
		\ENDIF
		\STATE Sposta EAX a destra
		\STATE Aggiungi il flag carry (che prende il valore rimosso da EAX) al registro CL
	\ENDWHILE
	\STATE Sposta il byte in CL nella locazione \texttt{0x00000104}
\end{algorithmic}
\end{algorithm}

\subsubsection{Istruzioni assembler}
Le istruzioni assembler si dividono in:
\begin{itemize}
	\item \textbf{Operative:} ovvero quelle che svolgono qualche operazione (ADD, SHR, MOV, CMP, ....);
	\item \textbf{Di controllo}: cioè che si occupano di altreare il flusso del programma (JMP, JE, ecc...).
\end{itemize}

\par\medskip
\noindent
\textsf{\textbf{Indirizzamento delle istruzioni operative}} \\
Le istruzioni operative si indirizzano attraverso l'\textbf{OPCODE} (codice operazione, ADD, MOV, ecc...), seguito da un suffisso (\textbf{B}, \textit{byte} da 8 bit, \textbf{W}, \textit{word} da 16 bit o \textbf{L}, \textit{long} da 32 bit) che può essere omesso, e gli indirizzi sorgente e destinazione.

\begin{itemize}
	\item 
Si possono \textbf{indirizzare i registri} sia come sorgenti che come destinatari, ovvero gli 8 registri generali da 32 bit, gli 8 registri generali da 16 bit, e gli 8 registri generali da 8 bit (disponibili solo sui registri A, B, C e D).
Bisogna precedere i nomi dei registri con \textbf{\%}.
	\item
Si può avere \textbf{indirizzamento immediato}, ovvero di costanti preceduti da \textbf{\$}, solo sull'operando sogente.
	\item
		Si può \textbf{indirizzare la memoria}, ma solo da sorgente o solo da destinatario, specificando un'indirizzo di memoria da 32 bit.
Ergo non posso scrivere:

\begin{lstlisting}[style=codestyle]	
MOVB pippo, pluto
\end{lstlisting}

ma devo scrivere:

\begin{lstlisting}[style=codestyle]	
MOV pippo, %EAX	% qua il suffisso di lunghezza e' implicito
MOVL %EAX, pluto
\end{lstlisting}

L'indirizzamento della memoria, nel caso più generale, è dato da: 

$$ \text{indirizzo} = \text{base} + \text{indice} \times \text{scala} \pm \text{displacement} $$

dove base e indice sono due registri generali da 32 bit, scala una costante dal valore 1 (default), 2, 4, 8, e displacement una costante intera.

La sintassi è \texttt{OPCODEsfx $\pm$disp(base,indice,scala)}.

Si distingue poi l'indirizzamento di tipo:

\begin{itemize}
	\item 
		\textbf{Diretto}, dove si indica soltanto il displacement, che coincide con l'indirizzo. \texttt{OPCODEW 0x00002001} significa prendi la word a partire da \texttt{0x00002001}.
	\item
		\textbf{Indiretto}, o con registro puntatore, dove si sfrutta un registro: \texttt{OPCODEL (\%EBX)} significa indirizzare il valore indirizzato da EBX. Si può specificare una scala: \texttt{OPCODEL (,\%EBX,4)} significa il valore nel registro EBX moltiplicato per 4.
		Si noti come a essere moltiplicato è l'indice e non la base.
	\item
		\textbf{Displacement e registro di modifica}, ad esempio da \texttt{OPCODEW 0x002A3A2B (\%EDI)} si ottiene l'operando a 16 bit ottenuto sommando al displacement \texttt{0x002A3A2B} il contenuto di EDI, modulo $2^32$.
	\item \textbf{Bimodificato senza displacement}, ad esempio \texttt{OPCODEW (\%EBX, \%EDI)}, che dipende sia da EBX che da EDI. Si può anche includere una scala: \texttt{OPCODEW (\%EBX, \%EDI, 8)}.
\item \textbf{Bimodificato con displacement}, come prima ma con displacement: \texttt{OPCODEB 0x002F9000 (\%EBX, \%EDI)}, ovvero l'indirizzo dato da base in EBX + indice in EDI + l'offset modulo $2^32$. Si può avere anche negativo: \texttt{OPCODEB -0x9000 (\%EBX, \%EDI)}, dove si sottrae l'offset invece di sommarlo.
\end{itemize}

Notare che senza il \$ i numeri in formato esadecimale sono interpretati automaticamente come indirizzi.

\item
Si possono \textbf{indirizzare le porte I/O}, come prima in uno solo dei due operandi. 
Questo si fa con le istruzioni specifiche IN e OUT.
In particolare si ha indirizzamento di tipo:

\begin{itemize}
	\item \textbf{Diretto}, solo per indirizzi $ < 256 $, in quanto nel formato macchina ci sono 8 bit.
		Ad esempio \texttt{IN 0x001A, \%AL} o \texttt{OUT \%AL, 0x003A}.
	\item \textbf{Indiretto con registro puntatore}, usando come registro puntatore soltanto DX.
		Ad esempio \texttt{IN (\%DX), \%AX} o \texttt{OUT \%AL, (\%DX)}.
\end{itemize}

\end{itemize}

\subsection{Panoramica sulle istruzioni}
Abbiamo diviso le istruzioni in \textbf{operative} e \textbf{di controllo}.
Possiamo fare ulteriori suddivisioni:

\begin{itemize}
	\item \textbf{Operative:}
		\begin{itemize}
			\item Di trasferimento;
			\item Aritmetiche;
			\item Di traslazione/rotazione:
			\item Logiche.
		\end{itemize}
	\item \textbf{Di controllo:}
		\begin{itemize}
			\item Di salto;
			\item Di gestione di sottoprogrammi.
		\end{itemize}
\end{itemize}

Conviene definire formato, funzionamento, comportamento sui flag e modalità di indirizzamento ammesse per gli operandi di ogni operazione, in quanto l'assembler non è \textbf{ortogonale}, ergo ci sono particolari restrizioni su \textit{quali} operandi e modalità di indirizzamento possono essere combinate.

\end{document}
