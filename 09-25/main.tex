\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{25-09-24}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPA, POPAD, POPF, POPFD, PUSH, PUSHA, PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW,
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 25-09-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Introduzione all'Assembler}

\subsubsection{Codifica macchina e codifica mnemonica}
Possiamo adottare 2 metodi per codificare le istruzioni eseguite dal processore:

\begin{itemize}
	\item \textbf{Codifica macchina:} la serie di zeri e di uni che codificano, nel linguaggio del processore, le operazioni che esegue.
		Il formato macchina è, nell'architettura che ci interessa, il seguente:

		\begin{table}[h!]
			\center \rowcolors{2}{white}{black!10}
			\begin{tabular} { c | c | p{7cm} }
				\bfseries Segmento & \bfseries Byte & \bfseries Funzione \\
				\hline 
				I Prefix (Instruction Prefix) & 0/1 byte & Modifica l'istruzione. \\ 
				O Prefix (Operand-size prefix) & 0/1 byte & Modifica la dimensione degli operandi. \\
				Opcode & 1/2 byte & Specifica l'operazione. \\
				Mode (ModR/M Byte) & 0/1 byte & Specifica la modalità d'indirizzamento e i registri operandi. \\ 
				SIB Byte & 0/1 byte & Viene usato in congiunzione con il Mod/RM btye quando si usa l'indirizzamento complesso (scale-index-base). \\
				Displacement & 0/1/2/4 byte & Specifica un'offset in memoria, sempre nell'indirizzamento complesso. \\
				Immediate & 0/1/2/4 byte & Specifica le costanti ad indirizzamento immediato.
			\end{tabular}
		\end{table}

	\item \textbf{Codifica mnemonica:} un modo \textbf{simbolico} per riferirsi alle istruzioni.
		Un'istruzione può quindi essere semplicemente: \lstinline|MOV %EAX, 0x01F4E39|.
\end{itemize}

Il linguaggio assembler usa la codifica mnemonica delle istruzioni, e dispone di sovrastrutture sintattiche che lo rendono più comprensibile agli umani.
Ad esempio, permette l'uso di nomi simbolici per locazioni di memoria: \lstinline|MOV %EAX, pippo|.

\subsubsection{Istruzioni in codifica mnemonica}
Un'istruzione ha 3 campi:
\begin{itemize}
	\item \textbf{Codice operativo:} stabilisce quale operazione eseguire;
	\item \textbf{Suffisso di lunghezza:} stabilisce la lunghezza (che può variare) degli operandi;	
	\item \textbf{Operandi:} gli operandi su cui si applica l'operazione. 
		Possono essere contenuti in registri, in celle di memoria, nelle porte I/O o direttamente nell'istruzione (\textbf{costanti}).
\end{itemize}

Il suffisso di lunghezza può essere omesso quando è chiaro (essenzialmente quando si usa un registro).

Sintatticamente la struttura è \lstinline|OPCODEsuffix source, dest|, che diventa qualcosa come \lstinline|ADD %BX, pluto|.
Questa istruzione effettua l'operazione \lstinline|ADD| (aggiungi), aggiungendo al registro \lstinline|BX| ciò che è contenuto nel simbolo \lstinline|pluto|.

\par\medskip
\noindent
\textsf{\textbf{Operandi di istruzioni}} \\
Le istruzioni ammettono 0, 1 o 2 operandi.
Quando sono 2, il primo operando si chiama \textbf{sorgente} e il secondo \textbf{destinatario}, e solitamente hanno la stessa lunghezza.
Quando è 1, l'operando può essere sia sorgente che destinatario a seconda dell'istruzione.

\subsubsection{Primo esempio di programma}

Si presenta un programma per contare il numero di uno trovati dalla locazione \lstinline|0x00000100| a \lstinline|0x00000103| e scriverlo nella locazione \lstinline|0x00000104|. 

\begin{lstlisting}[style=codestyle]	
MOVB $0x00, %CL					# sposta $0x00 in %CL
MOVL 0x00000100, %EAX		# sposta 32 bit da 0x00000100 a %EAX
CMPL $0x00000000, %EAX	# confronta 32 bit di 0 con il registro %EAX
JE   %EIP+$0x07					# salta se uguale a %EIP+$0x07, 
												#	ergo 0x0000020C + 0x07 = 0x00000213
SHRL %EAX								# trasla a destra %EAX
ADCB $0x00, %CL					# aggiungi a %CL 0 + carry 
JMP  %EIP-$0x0C					# salta incondizionato a %EIP-$0x0C,
												# ergo 0x00000213 - 0x0C = 0x00000207
MOVB %CL, 0x00000104		# sposta byte da %CL a 0x00000104
\end{lstlisting}

Il programma svolge i seguenti passi:
\begin{algorithm}
\caption{Conta 0}
\begin{algorithmic}
	\STATE Inizializza il registro CL (Counter Low) a 0
	\STATE Sposta i 32 bit da \lstinline|0x00000000| a \lstinline|0x00000103| in EAX
	\WHILE{true}	
		\IF{EAX è vuoto (tutti zeri)}
			\STATE Salta all'ultima istruzione
		\ENDIF
		\STATE Sposta EAX a destra
		\STATE Aggiungi il flag carry (che prende il valore rimosso da EAX) al registro CL
	\ENDWHILE
	\STATE Sposta il byte in CL nella locazione \lstinline|0x00000104|
\end{algorithmic}
\end{algorithm}

\subsubsection{Istruzioni assembler}
Le istruzioni assembler si dividono in:
\begin{itemize}
	\item \textbf{Operative:} ovvero quelle che svolgono qualche operazione (ADD, SHR, MOV, CMP, ....);
	\item \textbf{Di controllo}: cioè che si occupano di altreare il flusso del programma (JMP, JE, ecc...).
\end{itemize}

\par\medskip
\noindent
\textsf{\textbf{Indirizzamento delle istruzioni operative}} \\
Le istruzioni operative si indirizzano attraverso l'\textbf{OPCODE} (codice operazione, ADD, MOV, ecc...), seguito da un suffisso (\textbf{B}, \textit{byte} da 8 bit, \textbf{W}, \textit{word} da 16 bit o \textbf{L}, \textit{long} da 32 bit) che può essere omesso, e gli indirizzi sorgente e destinazione.

\begin{itemize}
	\item 
Si possono \textbf{indirizzare i registri} sia come sorgenti che come destinatari, ovvero gli 8 registri generali da 32 bit, gli 8 registri generali da 16 bit, e gli 8 registri generali da 8 bit (disponibili solo sui registri A, B, C e D).
Bisogna precedere i nomi dei registri con \textbf{\%}.
	\item
Si può avere \textbf{indirizzamento immediato}, ovvero di costanti preceduti da \textbf{\$}, solo sull'operando sogente.
	\item
		Si può \textbf{indirizzare la memoria}, ma solo da sorgente o solo da destinatario, specificando un'indirizzo di memoria da 32 bit.
Ergo non posso scrivere:

\begin{lstlisting}[style=codestyle]	
MOVB pippo, pluto
\end{lstlisting}

ma devo scrivere:

\begin{lstlisting}[style=codestyle]	
MOV pippo, %EAX	# qua il suffisso di lunghezza e' implicito
MOVL %EAX, pluto
\end{lstlisting}

L'indirizzamento della memoria, nel caso più generale, è dato da: 

$$ \text{indirizzo} = \text{base} + \text{indice} \times \text{scala} \pm \text{displacement} $$

dove base e indice sono due registri generali da 32 bit, scala una costante dal valore 1 (default), 2, 4, 8, e displacement una costante intera.

La sintassi è \lstinline|OPCODEsfx +/- disp(base,indice,scala)|.

Si distingue poi l'indirizzamento di tipo:

\begin{itemize}
	\item 
		\textbf{Diretto}, dove si indica soltanto il displacement, che coincide con l'indirizzo. \lstinline|OPCODEW 0x00002001| significa prendi la word a partire da \lstinline|0x00002001|.
	\item
		\textbf{Indiretto}, o con registro puntatore, dove si sfrutta un registro: \lstinline|OPCODEL (%EBX)| significa indirizzare il valore indirizzato da EBX. Si può specificare una scala: \lstinline|OPCODEL (,%EBX,4)| significa il valore nel registro EBX moltiplicato per 4.
		Si noti come a essere moltiplicato è l'indice e non la base.
	\item
		\textbf{Displacement e registro di modifica}, ad esempio da \lstinline|OPCODEW 0x002A3A2B (%EDI)| si ottiene l'operando a 16 bit ottenuto sommando al displacement \lstinline|0x002A3A2B| il contenuto di EDI, modulo $2^{32}$.
	\item \textbf{Bimodificato senza displacement}, ad esempio \lstinline|OPCODEW (%EBX, %EDI)|, che dipende dalla somma di EBX e EDI. Si può anche includere una scala: \lstinline|OPCODEW (%EBX, %EDI, 8)|, che va a moltiplicare solo \lstinline|%EDI|.
	\item \textbf{Bimodificato con displacement}, come prima ma con displacement: \lstinline|OPCODEB 0x002F9000 (%EBX, %EDI)|, ovvero l'indirizzo dato da base in EBX + indice in EDI + l'offset modulo $2^{32}$. Si può avere anche negativo: \lstinline|OPCODEB -0x9000 (%EBX, %EDI)|, dove si sottrae l'offset invece di sommarlo.
\end{itemize}

Notare che senza il \$ i numeri in formato esadecimale sono interpretati automaticamente come indirizzi.
Inoltre, i suffissi di dimensione si riferiscono al numero di locazioni all'indirizzo \textit{puntato} dai registri, non alla dimensione dei registri o altre cose ridicole. 

\item
Si possono \textbf{indirizzare le porte I/O}, come prima in uno solo dei due operandi. 
Questo si fa con le istruzioni specifiche IN e OUT.
In particolare si ha indirizzamento di tipo:

\begin{itemize}
	\item \textbf{Diretto}, solo per indirizzi $ < 256 $, in quanto nel formato macchina ci sono 8 bit.
		Ad esempio \lstinline|IN 0x001A, %AL| o \lstinline|OUT %AL, 0x003A|.
	\item \textbf{Indiretto con registro puntatore}, usando come registro puntatore soltanto DX.
		Ad esempio \lstinline|IN (%DX), %AX| o \lstinline|OUT %AL, (%DX)|.
\end{itemize}

\end{itemize}

\subsection{Panoramica sulle istruzioni}
Abbiamo diviso le istruzioni in \textbf{operative} e \textbf{di controllo}.
Possiamo fare ulteriori suddivisioni:

\begin{itemize}
	\item \textbf{Operative:}
		\begin{itemize}
			\item Di trasferimento;
			\item Aritmetiche;
			\item Di traslazione/rotazione:
			\item Logiche.
		\end{itemize}
	\item \textbf{Di controllo:}
		\begin{itemize}
			\item Di salto;
			\item Di gestione di sottoprogrammi.
		\end{itemize}
\end{itemize}

Conviene definire formato, funzionamento, comportamento sui flag e modalità di indirizzamento ammesse per gli operandi di ogni operazione, in quanto l'assembler non è \textbf{ortogonale}, ergo ci sono particolari restrizioni su \textit{quali} operandi e modalità di indirizzamento possono essere combinate.

\end{document}
