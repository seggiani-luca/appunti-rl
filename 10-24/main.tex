
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 24-10-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsubsection{Rappresentazione dei numeri interi}
Vogliamo rappresentare numeri interi su $n$ cifre.
Finora avevamo definito la legge di rappresentazione:
$$
A = \sum_{i=0}^{n-1} a_i \cdot \beta^i
$$
per i numeri naturali.

Nel sistema decimale, usiamo solutamente la rappresentazione \textbf{modulo e segno}, cioè usiamo un segno prefisso ($+$ o $-$), e poi indichiamo il modulo come un naturale.

In base 2, invece, decidiamo di sfruttare la seguente proprietà: preso un insieme di $\beta^n$ numeri interi, posso sempre trovare una legge biunivoca che gli fa corrispondere un insieme di $\beta^n$ numeri naturali.

Definisco quindi una legge $L: \mathbb{Z} \rightarrow \mathbb{N}$, e chiamo $A$ un numero naturale (che indicheremo in Maiuscolo da qui in avanti) e $a$ un numero intero (che indicheremo in minuscolo da qui in avanti).
Si ha quindi che:
$$
A = L(a) \Leftrightarrow a = L^{-1}(A)
$$
e cioè:
$$ 
a \leftrightarrow^L A \equiv (a_{n-1}a_{n-2}...a_1a_0)_\beta
$$
cioè con la stessa sequenza di cifre indichiamo sia un naturale che il corrispondente intero.
Notiamo che la $a$ minuscola qui significa \textit{cifra}, che è indifferentemente di $A$ o di $a$ (numeri naturali e interi).

Scegliendo leggi $L$ valide possiamo otttenere dei significativi vantaggi implementativi: ad esempio potremmo definire una legge che permette di usare la stessa circuiteria per le operazioni aritmetiche sia sui naturali che sugli interi.

Il \textbf{dominio} di $L$ dovrà essere contiguo, cioè un'intervallo, magari il più simmetrico possibile rispetto allo zero.
Questo è possibile solo se $\beta$ è dispari.
Nel caso di $\beta$ pari, come sarà nel nostro caso di interesse $\beta = 2$, dovremmo prendere un numero "in più" a destra o a sinistra.
Nel sistema adottato (sarà il complemento a 2) prendiamo il numero a sinistra, cioè quello negativo, ergo avremo l'\textbf{intervallo di rappresentabilità}:
$$
\left[ -\frac{\beta^n}{2}, \frac{\beta^n}{2} - 1 \right]
$$

Notiamo che da qui in poi assumeremo di lavorare in $\beta$ pari, in quanto in caso contrario dovremmo usare la seguente notazione:
$$
\left\lfloor -\frac{\beta^n}{2} \right\rfloor, \quad \left\lceil -\frac{\beta^n}{2} \right\rceil, \quad ...
$$
che appesantirebbe la trattazione, cosa inutile in quanto abbiamo stabilito che il nostro interesse finale è trovare metodi che si applichino a $\beta = 2$.

Abbiamo infatti che, posto $\beta=2$, l'intervallo riportato precedentemente rappresenta quello a cui siamo abituati per la rappresentabilità dei numeri interi in complemento a 2:
$$
\left[ -2^{n-1}, 2^{n-1} - 1 \right]
$$

\subsubsection{Rappresentazione in traslazione}
Una possibile legge di rappresentazione è data da:
$$
L(a) = A = a + \frac{\beta^n}{2}
$$
chiamiamo $\frac{\beta^n}{2}$ \textbf{fattore di polarizzazione}.
Questa rappresentazione è utile, \textbf{monotona} ($a < b \Leftrightarrow A < B$), e viene usata nei convertitori analogico/digitale e digitale/analogico, dove viene chiamata \textit{binario bipolare}.
Inoltre, ricordiamo che rappresenta l'esponente nei numeri reali in virgola mobile secondo lo standard IEEE 754.

Su un grafico dove le ordinate rappresentano $A$ e le ascisse $a$, abbiamo la mappa:
\begin{center}
	\begin{tikzpicture} [scale=0.9]
    \begin{axis}[
        axis lines=middle,
        xlabel={$a$},
        ylabel={$A$},
				xtick={-0.5,0.5},
				ytick={0,0.5,1},
				xticklabels={$-\frac{\beta^n}{2}$, $\frac{\beta^n}{2} - 1$},
				yticklabels={$0$, $\frac{\beta}{2}$, $\beta^n - 1$},
				axis line style = {-}, % Use this line to remove arrows
				] 


		\addplot[domain=-0.5:0.5, black, thick] {x+0.5};

    \end{axis}
\end{tikzpicture}
\end{center}

\subsubsection{Complemento alla radice}
Definiamo la legge, che abbiamo solitamente chiamato \textbf{complemento a 2}:
\[
		L(a) = A =	
	\begin{cases}
		a, \quad \quad \quad  0 \leq a < \frac{\beta^n}{2} \\ 
		\beta^n + a, \quad -\frac{\beta^n}{2} \leq a < 0
	\end{cases}
\]

Con questa legge perdiamo la \textbf{monotoneità}.
Ciò nonostante, è la legge usata di norma dal processore.

Ricordiamo che graficamente si può rendere con il cosiddetto diagramma a farfalla:
\begin{center}
	\begin{tikzpicture} [scale=0.9]
    \begin{axis}[
        axis lines=middle,
        xlabel={$a$},
        ylabel={$A$},
				xtick={-0.5,0.5},
				ytick={0,0.5,1},
				xticklabels={$-\frac{\beta^n}{2}$, $\frac{\beta^n}{2} - 1$},
				yticklabels={$0$, $\frac{\beta}{2}$, $\beta^n - 1$},
				axis line style = {-}, % Use this line to remove arrows
				] 


		\addplot[domain=-0.5:0, black, thick] {x+1};
		\addplot[domain=0:0.5, black, thick] {x};

    \end{axis}
\end{tikzpicture}
\end{center}

\subsubsection{Modulo e segno}
Possiamo sempre usare la legge di rappresentazione in modulo e segno, cioè $(s, M) \leftrightarrow a$:
\[
	s=
	\begin{cases}
		0, \quad a \geq 0 \\ 
		1, \quad a < 0
	\end{cases} 
\]
$$
M = \mathrm{abs}(a)
$$
Notiamo che noi intendiamo, per modulo e segno, una rappresentazione deve $n$ bit rappresentano il modulo, e l'$n$-esimo bit rappresenta il segno, per un totale di $n+1$ bit.
Non stiamo quindi mettendo in relazione intervalli di naturali con intervalli di interi, ma intervalli di naturali complementati da un bit in più di segno, con intervalli di interi.
Abbiamo quindi che questo tipo di rappresentazione non ricade nella categoria definita prima.
Ricordiamo comunque che viene applicata per rappresentare il segno dei numeri reali reali in virgola mobile secondo lo standard IEEE 754.

\subsubsection{Determinazione del segno}
Posso determinare il segno di un numero intero $a$ dalle cifre della sua rappresentazione $A$:
\[
	\begin{cases}
		a \geq 0 \Leftrightarrow 0 \leq A < \frac{\beta^n}{2} \\	
		a < 0 \Leftrightarrow \frac{\beta^n}{2} \leq A \ \beta^n	
	\end{cases}
\]

Facciamo le solite considerazioni:

\begin{itemize}
	\item Il \textbf{massimo numero rappresentabile} è $\frac{\beta^n}{2} - 1$, che in CR ha rappresentazione $\left( \frac{\beta}{2} - 1, \beta, ..., \beta \right)_\beta$;
	\item Il \textbf{minimo numero rappresentabile} è $\frac{\beta^n}{2}$, che in CR ha rappresentazione $\left( \frac{\beta}{2}, 0, ..., 0 \right)_\beta$;
	\item Lo \textbf{0} coincide in $A$ e $a$, ergo vale 0 e ha rappresentazione in CR $\left( 0, ..., 0 \right)_\beta$;
	\item Il \textbf{-1} è $\beta^n-1$, che in CR ha rappresentazione $\left( \beta, ..., \beta \right)_\beta$.
\end{itemize}

Quindi, per capire se la rappresentazione $A$ è un numero naturale maggiore o minore di $\frac{\beta^n}{2}$, che equivale a capire se l'intero che rappresenta è maggiore o minore di zero, basta guardare la cifra più significativa:
\[
	\begin{cases}
		a_{n-1} < \frac{\beta}{2} \Leftrightarrow 0 \leq A < \frac{\beta^n}{2} \\ 	
		a_{n-1} \geq \frac{\beta}{2} \Leftrightarrow \frac{\beta^n}{2} \leq A < \beta^n \\ 	
	\end{cases}
\]

Questo ci permette di riscrivere $L$ nella forma più elegante:
\[
		L(a) = A =	
	\begin{cases}
		a, \quad \quad \quad  a_{n-1} < \frac{\beta}{2} \\ 
		\beta^n + a, \quad a_{n-1} \geq \frac{\beta}{2}
	\end{cases}
\]


\subsubsection{Legge inversa del CR}
Possiamo ottenere per sostituzione la legge inversa della legge di rappresentazione CR:
\[
		L(a) = A =	
	\begin{cases}
		a, \quad \quad \quad  0 \leq a < \frac{\beta^n}{2} \\ 
		\beta^n + a, \quad -\frac{\beta^n}{2} \leq a < 0
	\end{cases}, \quad 
		L^{-1}(A) = a =
	\begin{cases}
		A, \quad \quad \quad 0 \leq A < \frac{\beta^n}{2} \\ 
		A - \beta^n, \quad \frac{\beta^n}{2} \leq A < \beta^n 
	\end{cases} 
\]

Che possiamo riscrivere nel modo più elegante:
\[
	L^{-1}(A) = a =
	\begin{cases}			
		A, \quad \quad \quad \quad a_{n-1} < \frac{\beta}{2} \\ 
		-\left( \overline{A} + 1 \right), \quad a_{n-1} \geq \frac{\beta}{2} 
	\end{cases}
\]
usando quanto detto sulla MSD e quanto conoscevamo sui complementi (ancora, è sostanzialmente un complemento a 2).

In particolare, il cambio delle disequazioni viene fatto note le propietà sul MSD.
La trasformazione $A - \beta^n = -\left( \overline{A} + 1 \right)$ si ricava invece dalla proprietà fondamentale:
$$
A + \overline{A} = \beta^n - 1
$$
con semplici passaggi algebrici.

\subsubsection{Forma alternativa del CR}
Possiamo usare la forma più concisa (ma anche più pericolosa) delle legge di rappresentazoine CR:
\[
	L(a) = A = |a|_{\beta^n}, \quad \text{se} \, -\frac{\beta^n}{2} \leq a < \frac{\beta^n}{2} - 1
\]

Abbiamo che:
\begin{enumerate}
	\item Se $a \geq 0$, allora è anche $< \beta^n$, quindi $A = a = |a|_{\beta^n}$;
	\item Se $a < 0$, allora è compreso in $\left[ -\frac{\beta^n}{2}, 0 \right[$, quindi diviso $\beta^n$ dà quoziente $-1$, cioè dal teorema della divisione con resto, $a = -1\cdot \beta^n + |a|_{\beta^n}$.
			Avevamo dalla legge di rappresentazione in complemento a radice che, sotto questa ipotesi, volevamo esattamente $\beta^n + a$, ergo si ottiene ugualmente $A = |a|_{\beta^n}$.
\end{enumerate}

Possiamo quindi interpretare il complemento a radice come una rappresentazione modulare:
\begin{center}
	\begin{tikzpicture} [scale=0.9]
    \begin{axis}[
        axis lines=middle,
        xlabel={$a$},
        ylabel={$A$},
				xtick={-1, -0.5,0.5, 1},
				ytick={0,0.5,1},
				xticklabels={$-\beta^n$, $-\frac{\beta^n}{2}$, $\frac{\beta^n}{2} - 1$, $\beta^n$},
				yticklabels={$0$, $\frac{\beta}{2}$, $\beta^n - 1$},
				axis line style = {-}, % Use this line to remove arrows
				height=5cm,
				width=14cm
				] 

		\addplot[domain=-3:-2, black, thick] {x+3};
		\addplot[domain=-2:-1, black, thick] {x+2};
		\addplot[domain=-1:0, black, thick] {x+1};
		\addplot[domain=0:1, black, thick] {x};
		\addplot[domain=1:2, black, thick] {x-1};
		\addplot[domain=2:3, black, thick] {x-2};
		\addplot[domain=2:3, black, thick] {x-2};

    \end{axis}
\end{tikzpicture}
\end{center}

Occorre fare attenzione in quanto questo è vero solo nel caso $a$ sia \textbf{rappresentabile}, cioè se rispetta: $ -\frac{\beta^n}{2} \leq a < \frac{\beta^n}{2} - 1 $. 
In caso contrario, come è chiaro dal grafico, si potrebbero avere le stesse rappresentazioni per interi diversi fra di loro (cioè essenzialmente un overflow).

\subsection{Operazioni su interi in CR}
Vogliamo progettare circuiti che lavorano sulle rappresentazioni, come avevamo fatto per i naturali.
Ricordiamo che la rappresentazione vale per un naturale $A$ o un intero $a$ a seconda di quanto deciso dal programmatore, e nient'altro.

\subsubsection{Valore assoluto}
Vogliamo trovare il valore assoluto di un numero intero $B = \mathrm{abs}(a)$, con: 
$$ a \in \left[ -\frac{\beta^n}{2}, \frac{\beta^n}{2} - 1 \right] \Rightarrow B \in \left[0, \frac{\beta^n}{2}\right]
$$
Si ha che $B$ è un numero naturale rappresentabile su $n$ cifre.
Sappiamo che:
\[
	\mathrm{abs}(a) =
	\begin{cases}
			a, \quad a \geq 0 \\ 
			-a, \quad \, a < 0 
	\end{cases}
\] 

Posso quindi ottenere $\mathrm{abs}(a)$ complementando la rappresentazione nel range di valori che so essere negativo (cioè quando $a_{n-1} \geq \frac{\beta}{2}$):
\[
	B = \mathrm{abs}(a) =
	\begin{cases}
		A, \quad \quad a_{n-1} < \frac{\beta}{2} \\ 
		\overline{A} +  1, \quad a_{n-1} \geq \frac{\beta}{2}
	\end{cases}
\]

Logicamente, questo sarà rappresentato da un multiplexer che discrimina fra $A$ e $\overline{A} - 1$.
La variabile di comando sara datà dal $b_{out}$ di un comparatore fra $a_{n-1}$ e $\frac{\beta}{2}$

In base 2 questo è notevolmente più semplice: avrò che basta prendere $a_{n-1}$ come variabile di comando.
Si potrà quindi complementare con uno XOR fra le cifre di A e $a_{n-1}$, e usare $a_{n-1}$ anche come ingresso di un incrementatore, con le cifre di $A$ all'altro ingresso.

\subsection{Conversione da CR a MS}
Vediamo come convertire un numero in CR nella rappresentazione modulo e segno.
Prima di tutto notiamo una discrepanza nell'intervallo di rappresentabilità:
$$
i_{MS} = [-\beta^n + 1, \beta^n - 1] \not\Leftrightarrow i_{CR} = \left[-\frac{\beta^n}{2}, \frac{\beta^n}{2}\right]
$$
Abbiamo però che $i_{CR} \subset i_{MS}$, tolto il bit di segno, quindi l'operazione è sempre fattibile, calcolando l'assoluto e stabilendo:
$$
\mathrm{sgn}(a) = 
	\begin{cases}
		0, \quad a_{n-1} < \frac{\beta}{2} \Leftrightarrow a_{n-1} = 0 \\ 
		1, \quad a_{n-1} \geq \frac{\beta}{2} \Leftrightarrow a_{n-1} = 1 \\ 
	\end{cases}
$$
dove si è riportato il valore di $a_{n-1}$ in base $\beta = 2$.

\subsection{Calcolo dell'opposto}
Vediamo come trovare l'opposto di un numero in CR, quindi dato $A \leftrightarrow a$, $B \leftrightarrow b$ tale che $ b = -a$.
Questo' operazione non è sempre possibile, a causa dell'asimmetria dell'intervallo di rappresentabilità in CR $\left[-\frac{\beta^n}{2}, \frac{\beta^n}{2}\right]$: avremo che il numero in $-\frac{\beta^n}{2}$, negativo, non ha opposto positivo rappresentabile.

Avremo quindi bisogno di un flag di overflow, diciamo \lstinline|ow|.
Le due uscite, l'opposto e \lstinline|ow|, andranno quindi calcolate separatamente.
Assumendo \lstinline|ow|$=0$, si ha:
$$
B = |-a|_{\beta^n} = \left||-1|_{\beta^n} \cdot |a|_{\beta^n} \right|_{\beta^n} = |(\beta^n - 1) \cdot A|_{\beta^n}
$$
$$
= |\beta^n \cdot A - A |_{\beta^n} = |-A|_{\beta^n} = |-\beta^n + 1 + \overline{A}|_{\beta^n} = |1 + \overline{A}|_{\beta^n}
$$
cioè si ritrova sostanzialmente la legge di rappresentazione inversa $L^{-1}$.

Sappiamo di poter implementare questa legge con una negazione di tutte le cifre, seguita da un incremento di 1.
Nel caso precedente, avevamo usato lo XOR in quanto volevamo che la negazione fosse condizionale (pilotata dal bit di segno).
In questo caso vogliamo negare sempre, quindi basta una porta NOT.

L'\lstinline|ow| viene invece impostato sulla base di un AND fra le cifre più significative $a_{n-1}$ del numero non negato e $b_{n-1}$ del numero negato.

\subsubsection{Richiamo all'assembly}
Si ricorda che in assembly avevamo l'istruzione \lstinline|NEG|, che interpretava una sequenza di bit come un numero intero, e ne calcolava l'opposto se possibile, impostando il flag OF altrimenti.

\subsection{Estensione di campo per gli interi}
Avevamo detto che l'estensione di campo per gli interi richiedeva logica.
Possiamo infatti ricavare, per via algebrica il valore dell'intero con l'$n$-esima cifra aggiunta, $A_{EST}$:

$$
A_{EST} = 
	\begin{cases}
		a, \quad \quad \quad \quad 0 \leq a < \frac{\beta^n}{2} \\ 
		\beta^{n+1} + a, \quad -\frac{\beta^n}{2} \leq a < 0
	\end{cases}
	=
	\begin{cases}
		A, \quad \quad \quad \quad \quad \quad \quad 0 \leq a < \frac{\beta^n}{2} \\ 
		\beta^{n} \cdot (\beta - 1) + a, \quad -\frac{\beta^n}{2} \leq a < 0
	\end{cases}
$$
da cui troviamo:
$$
	=
	\begin{cases}
		0 \cdot \beta^n + A,  \quad \quad \quad \quad 0 \leq a < \frac{\beta^n}{2} \\ 
		\beta^{n} \cdot (\beta - 1) + a, \quad -\frac{\beta^n}{2} \leq a < 0
	\end{cases}
$$

Notiamo che i termini che moltiplicano $\beta^n$ sono quelli della cifra che vogliamo aggiungere.
Possiamo quindi definire la cifra aggiunta:
$$
a_n =
	\begin{cases}
		0, \quad \quad a_{n-1} < \frac{\beta^n}{2} \\ 
		\beta -1 \quad a_{n-1} \geq \frac{\beta^n}{2}
	\end{cases}
$$

Graficamente, possiamo pensare all'estensione di campo come una traslazione verso l'alto del lato sinistro dell'intervallo di ordinate, cioè quello che rappresenta gli interi negativi.
Più propriamente, se avevamo dato la rappresentazione $|a|_{\beta^n}$ per $A$, adesso dobbiamo prendere $|a|_{\beta^{n+1}}$ che graficamente dà:
\begin{center}
	\begin{tikzpicture} [scale=0.9]
    \begin{axis}[
        axis lines=middle,
        xlabel={$a$},
        ylabel={$A$},
				xtick={-2, -1, -0.5,0.5, 1, 2},
				ytick={0,0.5,1},
				xticklabels={$-\beta^{n+1}$, $-\beta^n$, $-\frac{\beta^n}{2}$, $\frac{\beta^n}{2} - 1$, $\beta^n$, $\beta^{n+1}$},
				yticklabels={$0$, $\frac{\beta}{2}$, $\beta^n - 1$},
				axis line style = {-}, % Use this line to remove arrows
				height=5cm,
				width=14cm
				] 

		\addplot[domain=-3:-2, red, thick] {x+3};
		\addplot[domain=-2:-1, red, thick] {x+2};
		\addplot[domain=-1:0, red, thick] {x+1};
		\addplot[domain=0:1, red, thick] {x};
		\addplot[domain=1:2, red, thick] {x-1};
		\addplot[domain=2:3, red, thick] {x-2};
		\addplot[domain=2:3, red, thick] {x-2};

		\addplot[domain=-2:0, blue, thick] {x+2};
		\addplot[domain=0:2, blue, thick] {x};
    \end{axis}
\end{tikzpicture}
\end{center}
da cui si nota ancora meglio che il lato per interi positivi resta tale, mentre il lato negativo trasla in alto (in rosso si ha $|a|_{\beta^n}$, e in blu $|a|_{\beta^{n+1}}$).

Dal punto di vista della base 2, questo tipo di estensore può essere realizzato semplicemente replicando la $n-1$-esima cifra.

\end{document}
