
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 03-10-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Assembler a 64 bit}
Finora abbiamo studiato il linguaggio assembler a 32 bit (registri estesi EAX, EBX, ecc...).
Vediamo adesso alcune caratteristiche dell'assembler a 64 bit.

Nei processori a 64 bit Intel-AMD x86 abbiamo 16 registri generali a 64 bit, con prefisso R, e che quindi si indicano come RAX, RBX, ecc...
Di questi si può indirizzare la parte estesa dei 32 bit meno significativi (EAX), i 16 bit meno significativi (AX), e gli 8 bit meno significativi (AL).
Per RAX, RBX, RCX e RDX si possono inoltre indirizzare gli 8 bit precedenti ad AL, BL, CL e DL usando AH, BH, CH e DH, ma questo è sconsigliato in quanto ci sono diverse limitazioni (non sono compatibili col prefisso REX).

Una lista completa dei registri genrali è la seguente, inclusi i nomi dei sottoregistri di dimensione minore:

\begin{table}[h!]
	\center \rowcolors{2}{white}{black!10}
	\begin{tabular} { c || c | c | c | c }
		\bfseries 64 bit & \bfseries 32 bit & \bfseries 16 bit & \bfseries 8 bit & \bfseries 8 bit (legacy) \\
		\hline 
		RAX & EAX & AX & AL & AH \\
		RBX & EBX & BX & BL & BH \\
		RCX & ECX & CX & CL & CH \\
		RDX & EDX & DX & DL & DH \\
		RSP & ESP & SP & SPL & \\
		RBP & EBP & BP & BPL & \\
		RSI & ESI & SI & SIL & \\
		RDI & EDI & DI & DIL & \\
		R8 &R8D &R8W &R8B & \\
		R9 &R9D &R9W &R9B & \\
		R10&R10D&R10W&R10B & \\
		R11&R11D&R11W&R11B & \\
		R12&R12D&R12W&R12B & \\
		R13&R13D&R13W&R13B & \\
		R14&R14D&R14W&R14B & \\
		R15&R15D&R15W&R15B & \\
	\end{tabular}
\end{table}

Ricordiamo poi i registri RIP, l'instruction pointer, e RFLAGS che è il registro dei flag.

\subsubsection{Spazio indirizzabile}
Tecnicamente con architettura a 64 bit si potrebbero indirizzare $2^{64}$ byte distinti, ma i processori moderni permettono di indirizzarne solo $2^{48} = 256 \ \mathrm{TiB}$, con alcuni modelli più recenti che arrivano a $2^{57}= 128 \ \mathrm{PiB}$.
I 47 (o 56) bit occupati sono i meno significativi, e i restanti 16 (o 7) devono avere il valore del bit più significativo utilizzato.
Questo significa che sono indirizzabili effettivamente due porzioni contigue ma separate fra di loro di memoria:
\begin{table}[h!]
	\center \rowcolors{2}{white}{black!10}
	\begin{tabular} { c | p{4cm} | p{4cm} }
		& \bfseries 48 bit & \bfseries 57 bit \\
		\hline
		\bfseries Regione alta & \texttt{0000 0000 0000 0000} \texttt{0000 7fff ffff ffff} & \texttt{0000 0000 0000 0000} \texttt{01ff ffff ffff ffff} \\
		\bfseries Regione bassa & \texttt{ffff 8000 0000 0000} \texttt{ffff ffff ffff ffff} & \texttt{fe00 0000 0000 0000} \texttt{ffff ffff ffff ffff} \\
	\end{tabular}
\end{table}

Lo spazio I/O, infine, è di $2^{16} = 64 \ \mathrm{KiB}$ locazioni.

\subsubsection{Istruzioni}
Le operazioni possono possono usare 1, 2, 4 o 8 byte per un operando (rispettivamente Byte, Word, Long e Quad).

Notiamo che non possiamo usare displacement o operandi immediati a 64 bit: siamo limitati a 32 bit.
Per ovviare a questo problema esiste una versione alternativa della \lstinline|MOV|:

\subsubsection{MOVABS}
\begin{itemize}
	\item \textbf{Formato:} \lstinline|MOVABS $const, destination|
	\item \textbf{Azione:} porta una costante a 64 bit (che ci permette di scrivere) in un indirizzo generale.
	\item \textbf{Flag:} nessuno.
\end{itemize}

		\begin{table}[H]
		\center \rowcolors{2}{white}{black!10}
			\begin{tabular} { c | p{5cm} }
				\bfseries Operandi & \bfseries Esempi \\
				\hline
				Immediato & \lstinline|MOVABS $0xffff8105402300ef, %RBX| \\ 
				Memoria & \lstinline|CALL 0x00ef0b2a, %RAX| \\ 
				Registro & \lstinline|CALL %RAX, 0x00ef0b2a|
			\end{tabular}
		\end{table}

\par\smallskip 
In generale, in assember a 64 bit si usano registri con valori base di 64 bit, e poi si indirizza con displacement a 32 bit, che in complemento a 2 concedono $\pm 2^{32}$, ergo $\pm 2 \mathrm{GB}$ di memoria indirizzabile rispetto alla base.

\subsection{Reti logiche}
Una rete logica è un modello astratto di un sistema fisico, costituito da dispositivi tra loro interconnessi.
Le informazioni vengono codificate da questi dispositivi attraverso fenomeni fisici che si presentano in due aspetti distinti (corrente forte / corrente debole, tensione forte / tensione debole, magnetizzazione / non magnetizzazione, ecc...).

\subsubsection{Caratterizzazione di rete logica}
Una rete logica è caratterizzata da:
\begin{itemize}
	\item Un'insieme di $N$ variabili di ingresso. Il loro valore all'istante temporale $t$ si chiama stato di ingresso. L'insieme di tutti i $2^N$ stati di ingresso si indicherà come $X.X = \{ x_{N-1} x_{N-2} ... x_1 x_0 \}$. 
	\item Un'insieme di $M$ variabili di uscita. Il loro valore all'istante temporale $t$ si chiama stato di uscita. L'insieme di tutti i $2^M$ stati di uscita si indicherà come $Z.Z = \{ x_{M-1} x_{M-2} ... x_1 x_0 \}$. 
	\item Una legge di evoluzione che determina come le uscite si evolvono in funzione degli ingressi.
\end{itemize}

Possiamo classificare le reti logiche in base a 2 criteri riguardanti l'evoluzione nel tempo:
\begin{itemize}
	\item \textbf{Presenza/assenza di memoria}:
		\begin{itemize}
			\item \textbf{Reti combinatorie:} analoghe a funzioni matematiche, le loro uscite dipendono solo dai loro ingressi in un qualsiasi istanti $t$;
			\item \textbf{Reti sequenziali:} lo stato di uscita dipende dalla storia degli ingressi precedenti, ergo sono reti con memoria.
		\end{itemize}
	\item \textbf{Temporizzazione della legge di evoluzione:}
		\begin{itemize}
			\item \textbf{Reti asincrone:} l'aggiornamento delle uscite avviene costantemente nel tempo;
			\item \textbf{Reti sincronizzate:} l'aggiornamento delle uscite avviene ad istanti di sincronizzazione discreti nel tempo.
		\end{itemize}
\end{itemize}

I modelli sono ortogonali, ergo possiamo avere qualsiasi delle 4 combinazioni di queste caratteristiche:
\begin{itemize}
	\item Reti combinatorie (si considerano le sincronizzate come caso particolare);
	\item Reti sequenziali asincrone;
	\item Reti sequenziali sincronizzate.
\end{itemize}

Quindi in sostanza una rete logica comunica con l'esterno attraverso variabili logiche (0 e 1).
L'interpretazione di questi messaggi è una convenzione del progettista, programatore, ecc...

Usiamo le reti logiche per modellizzare circuiti elettronici all'interno del calcolatore, che codificano le informazioni in tensione.
Notiamo quindi che una rete logica fisica ha, oltre agli ingressi e alle uscite, i collegamenti ai terminali positivi e negativi di un generatore di tensione, che noi ignoreremo. 

\subsection{Transizione dei segnali}
Una variabile logica (per noi il voltaggio su un circuito) può settarsi (andare a 1), restare settato per tempi paragonabili a $\Delta T$, e resettarsi (andare a 0) in un qualsiasi momento temporale $t$:

\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        xlabel={$t$},
        ylabel={$V$},
        xmin=0, xmax=14,
        ymin=-1, ymax=6,
        grid=major,
        domain=0:14,
				xtick={5,8},
				ytick={0,5},
				xticklabels={$t_1$,$t_2$},
				yticklabels={$0$, $V_{max}$},
        samples=100,
        legend pos=south west,
    		width=14cm,
				height=7cm
			]
    \addplot[blue, thick] {5 * (x >= 5) * (x <=  8)};
    \end{axis}
\end{tikzpicture}
\end{center}

In un sistema fisico reale, durante la transizione c'è un periodo di indecisione in cui il voltaggio sale o scende fisicamente fino al valore necessario, sotto l'atto di una qualche potenza. Vediamo il grafico a $\Delta t << \Delta T$:

\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        xlabel={$t$},
        ylabel={$V$},
        xmin=4.8, xmax=5.2,
        ymin=-1, ymax=6,
        grid=major,
        domain=0:14,
				xtick={5,8},
				ytick={0,5},
				xticklabels={$t_1$,$t_2$},
				yticklabels={$0$, $V_{max}$},
        samples=100,
        legend pos=south west,
    		width=14cm,
				height=7cm
			]
    \addplot[blue, thick] {5 * (x >= 5) * (x <=  8)};
    \end{axis}
\end{tikzpicture}
\end{center}

Decidiamo di ignorare questo problema, in quanto abbiamo visto che il $\Delta t$ di transizione è molto più piccolo del $\Delta t$ di stasi delle variabili.

Il problema si presenta nel caso si parli di \textbf{contemporaneità}. 
Supponiamo di avere una rete logica con due ingressi $x_0$ e $x_1$ e un'uscita $z_0$.
Abbiamo che prima dell'istante $t_1$ lo stato di ingresso è $(1,0)$, e che subito dopo lo stesso stato è $(0, 1)$.
Nell'istante di transizione non abbiamo la sicurezza che le singole transizioni delle due variabili della rete avvengano contemporaneamente:

\begin{tikzpicture}
    \begin{axis}[
        xlabel={$t$},
        ylabel={$V$},
        xmin=0, xmax=8,
        ymin=-1, ymax=6,
        grid=major,
        domain=0:8,
        samples=100,
				xtick={3},
				ytick={0,5},
				xticklabels={$t_1$},
				yticklabels={$0$, $V_{max}$},
        legend pos=south west,
    		width=14cm,
				height=7cm
			]
    \addplot[blue, thick] {5 * (x >= 3)};
    \addplot[red, thick] {5 * (x >= 3.5) + 0.25};
    \end{axis}
\end{tikzpicture}

Questa considerazione è importante nel caso delle reti logiche asincrone, dove considerare le transizioni come contemporanee potrebbe portare alla comparsa di stati di uscita spuri, e nelle reti sequenziali, dove potrebbe portare ad evoluzioni imprevedibili del sistema.

\subsection{Reti combinatorie}
Una rete combinatoria è caratterizzata da:
\begin{itemize}
	\item Un'insieme di $N$ variabili logiche di ingresso;
	\item Un'insieme di $M$ variabili logiche di uscita;
	\item Una descrizione funzionale $F: X \rightarrow Z$ che mappa stati di ingresso a stati di uscita;
	\item Una legge di evoluzione nel tempo che adegua $F(X)$ allo stato di ingresso $X$ continuamente.
\end{itemize}

\subsubsection{Tempo di attraversamento}
Il tempo di attraversamento (o di accesso) è una caratteristica di tutte le reti logiche asincrone: è il tempo necessario perché la rete si "accorga" della variazione degli ingressi e aggiorni di conseguenza le sue uscite.

Questo tempo è solitamente non nullo, ed è quindi necessario attendere che la rete arrivi a \textbf{regime} prima di valutare le uscite.
Questo vincolo prende il nome di \textbf{pilotaggio in modo fondamentale}: si dice che è una rete è pilotata in modo fondamentale quando chi la pilota aspetta sempre che essa arrivi a regime prima di valutare le sue uscite.
\end{document}
