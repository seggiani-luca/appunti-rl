
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 14-11-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Riconoscitore di sequenze}
Un \textbf{riconoscitore di sequenze} è una rete sequenziale sincronizzata a $N$ ingressi ed un uscita.
Questa rete si evolve secondo la legge seguente: se si presenta, in sequenza, una sequenza di stati di ingresso voluta, l'uscita vale 1, 0 altrimenti.

Ogni stato di ingresso deve essere presentato prima del prossimo ciclo di clock, e per $n$ stati di ingresso avremo bisogno di $n$ cicli di clock per leggerli tutti.
Inoltre, se un valore permane per più di un ciclo di clock, si considera questa una ripetizione (e quindi un eventuale errore nel codice).

Si ha, di base, che il riconoscitore di sequenze è una \textbf{rete con memoria}: deve ricordare ad ogni stato di ingresso la sequenza degli stati di ingresso \textbf{corretti} e \textbf{consecutivi} visti finora, cioè $K + 1$ stati (compreso lo stato finale con l'uscita a 1) per sequenze di $K$ stati (almeno se sintetizzata come rete di Moore).

Vediamo quindi come sintetizzare tale circuito, sia come rete di Moore che come rete di Mealy:

\subsubsection{Sintesi in rete di Moore}
\lstinputlisting[language=verilog, style=codestyle]{../verilog/11-14/sequence_detectors/moore_sequence_detector.v}

\subsubsection{Sintesi in rete di Mealy}
\lstinputlisting[language=verilog, style=codestyle]{../verilog/11-14/sequence_detectors/mealy_sequence_detector.v}

\subsection{Confronto fra Moore e Mealy}
Notiamo come, nell'esempio, la rete di Mealy risparmia su uno stato, in quanto può leggere direttamente gli ingressi e impostare l'uscita a 1 quando rileva la sequenza giusta nel penultimo stato.

Abbiamo in generale, infatti, che le reti di Moore hanno leggi $B$ meno flessibili delle reti di Mealy, e quindi in una rete di Mealy si hanno meno stati interni che in una rete di Moore.
Si potrebbe quindi pensare che una rete di Mealy può esprimere funzioni che una rete di Moore non può rappresentare.
Questo è falso, in quanto si può dimostrare che Moore e Mealy hanno la \textbf{stessa potenza descrittiva}: per una rete di Moore, si può ricavare l'equivalente di Mealy, e viceversa.

Tra le altre differenze che possiamo notare, si ha che il clock di una rete di Moore al pari di una rete di Mealy deve essere più veloce, e sopratutto che una rete di Mealy si aggiorna \textit{al pari} con gli ingressi, cioè è una rete \textbf{trasparente}.

Un anello di retroazione fra due reti di Mealy può infatti creare un \textbf{anello combinatorio}, che sappiamo essere suscettibile a oscillazioni incontrollate.
Di contro, fra due reti di Moore incontreremo sempre un registro, ergo non avrmo problemi di formazione di anelli combinatori.

\subsection{Modello di Mealy ritardato}
Creiamo una cosiddetta rete di \textbf{Mealy ritardato} prendendo una rete di Mealy e introducendo un ulteriore registro, \textbf{OUTR}, in uscita.
Questo risolve il problema della trasparenza delle reti di Mealy: le uscite, come nelle reti di Moore, non sono più trasparenti e variano all'arrivo del clock dopo un tempo $T_{prop}$.

In una RSS di Mealy ritardato si hanno quindi i seguenti vincoli di pilotaggio, che vediamo corrispondono in pratica con quelli di una rete di Moore (tranne l'ultimo che non risente di una rete di conversione dagli stati interni, in quanto l'uscita si ricava direttamente da un registro):
\[
	\begin{cases}
		T \geq T_{hold} + T_{a\_monte} + T_{RC} + T_{setup} \\ 
		T \geq T_{prop} + T_{RC} + T_{setup} \\ 
		T \geq T_{prop} + T_{a\_valle}
	\end{cases}
\]

\subsection{Assegnamenti procedurali}
In Verilog possiamo descrivere il comportamento di una rete di Mealy attraverso i cosiddetti \textbf{assegnamenti procedurali}.
Notiamo la temporizzazione di una forma del tipo:
\begin{lstlisting}[language=verilog, style=codestyle]	
s0: begin STAR<=S1; OUTR<=STAR; end
\end{lstlisting}
Le istruzioni contenute nel blocco \lstinline|begin| (...) \lstinline|end| accadono \textbf{contemporaneamente}, e il fatto che STAR sia a sinistra nel primo assegnamento e OUTR sia sinistra nel secondo indica che questi avvengono \textit{dopo il clock}, cioè \textit{prima del clock} si legge il valore (S1 o STAR nell'esempio) e soltanto dopo si scrive effettivamente sul registro.

\subsection{Reti sequenziali complesse}
I modelli concettuali che abbiamo visto finora (Moore, Mealy e Mealy ritardato) riescono a sintetizzare solo reti molto semplici.
Prendiamo ad esempio il modello di Mealy ritardato.

Vogliamo creare una rete che conta, modulo 16, il numero di sequenze corrette 00, 01, 10 ricevute in ingresso.
Quindi, ogni volta che viene registrata una sequenza corretta, la rete incrementa di 1 l'uscita, rappresentata su 4 bit.
Abbiamo quindi \textbf{2 ingressi}, \textbf{4 uscite}, e 3 stati interni per 16 stati di OUTR, cioè 48 stati interni totali.

Modellizzare questa rete con un tale numero di ingressi risulta chiaramente molto laborioso: un apporccio migliore sarebbe creare una rete di Mealy ritardato che riconosce una sola sequenza, e mandarla in input a un contatore a 4 bit.
# potresti fare disegnini però è laborioso pure quello

\textit{Esplodendo} una rete siffatta troviamo un modello formato da una rete di Mealy ritardato (cioè da una rete combinatoria \textit{di riconoscimento} nel caso del riconoscitore di sequenza, annessa ai registri STAR e OUTR), e da un contatore (formato a sua volta da una rete combinatoria che implementa la logica del contatore e un altro registro, che chiameremo \textbf{COUNT}).
L'uscita di questa rete sarà formata dal registro COUNT, e potremo inoltre racchiudere le due reti combinatorie in un unica RC totale.

La rete così ottenuta non rispetta il modello di Mealy ritardato: ha più di due registri, e sopratutto fa rientrare nella RC totale più di un registro uscente (finora era stato STAR).
Troviamo che questo è molto comodo: introducendo \textbf{registri operativi} abbiamo a disposizione locazioni di memoria che supportano sia uscite che computazioni intermedie.

Possiamo quindi distinguere i registri in due categorie:
\begin{itemize}
	\item \textbf{Registri di stato:} simili a quelli che abbiamo già visto, cioò che rappresentano lo stato interno della rete;
	\item \textbf{Registri operativi:} che contengono sia \textit{valori di uscita} che \textit{valori intermedi} (o \textit{computazioni intermedie}, insomma risultati utili al ricavo dell'uscita della rete). 
\end{itemize}

\end{document}
