
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 06-11-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Collegamento al bus e maschere}
Resta da capire da dove vengono gli indirizzi di lettura usati nell'accesso alla SRAM.
Questi si trovano su un \textbf{bus indirizzi}, il cui valore è impostato dal processore ogni volta che vuole effettuare un accesso.
Ad esempio, per un modulo di RAM da $256 \text{M} \times 8$ bit, quindi con 28 ingressi, si avrà che bisogna di montare banchi di memoria a partire da \lstinline|0xE0000000| fino a \lstinline|0xEFFFFFFF|.

L'ingresso di select verrà quindi generato a partire dalla parte alta dell'indirizzo, fatto passare attraverso una certa maschera, facendo quindi corrispondere una certa impostazione dei bit più significativi (in questo caso 4) al segnale di select.
Visto che avevamo detto si parte da \lstinline|0xE0000000|, vogliamo \lstinline|0xE| = \lstinline|B1110|, quindi serve la rete combinatoria (maschera):
$$
\mathtt{/s} = \overline{a_{31}} + \overline{a_{30}} + \overline{a_{29}} + a_{28}
$$

Con un montaggio di questo tipo possiamo usare il select per scegliere quale banco di memoria RAM è associato a quale parte dello spazio indirizzabile.
Questo tipo di configurazione giustifica inoltre il fatto che il bit di select viene impostato con ritardo rispetto agli indirizzi: visto che deve essere calcolato sulla base di quest'ultimi, risentirà del ritardo della rete combinatoria che lo genera.

\subsection{Memorie ROM a sola lettura}
Le memorie a sola lettura, dette ROM, sono effettivamente reti combinatorie: l'uscita è costante qualunque siano gli stati passati.
Vengono montate nello spazio di memoria assieme alla RAM, e rappresentano la parte \textbf{non volatile} (persistente) dello spazio di memoria stesso (abbiamo visto come contengono le prime istruzioni eseguite dal processore).
La loro struttura interna ricalca quella della memoria RAM, privata della circuiteria necessaria alla lettura, e che usa generatori di costante al posto dei D-latch.

Una ROM può essere realizzata attraverso il MSU (\textit{Modello Strutturale Universale}), collegando in maniera ortogonale file di OR alle uscite di un decoder (come ci è concesso dall'espansione di Shannon), nei punti in cui vogliamo che un'uscita corrisponda a un certo ingresso.
Nella pratica, si usano più spesso porte NOR per ragioni elettroniche, e quindi si collegano le linee nel caso un uscita corrisponde alla negazione dell'ingresso.
Questo circuito viene solitamente stampato su un singolo chip di silicio, il cui costo fisso di progettazione è giustificato solo nel caso di produzione su larga scala.
Conviene quindi realizzare delle alternative, le \textbf{ROM programmabili}.

\subsubsection{ROM programmabili}
In una memoria ROM programmabile, le porte NOR sono tutte attaccate alle linee degli AND del decoder.
Si possono disabilitare selettivamente alcune di queste porte NOR per effettivamente \textbf{programmare} la memoria contenuta nella ROM.

Possiamo individuare delle categorie per queste reti:

\begin{itemize}
	\item Le \textbf{OTPROM} (\textit{One Time Programmable ROM}) vengono realizzate attraverso questa tecnologia, è la loro progammazione risulta quindi \textbf{distruttiva} (una volta programmato un bit non si può più rimuovere).
	\item  Una tecnologia più sofisticata è rappresentata dalle \textbf{EPROM} (\textit{Erasable programmable ROM}).
Queste vengono realizzate attraverso tranistor a field-effect.
La scrittura della EPROM può essere ripetuta sottoponendola a una luce ultravioletta, e quindi cancellando tutti i dati, per poi riscrivene altri.

Di una EPROM ci interessano:
\begin{itemize}
	\item \textbf{Endurance:} quante riscritture successive può supportare (solitamente dalle 10K alle 100K volte);
	\item \textbf{Data retention:} il periodo per cui si può fare affidamento sui dati contenuti in una EPROM (solitamente dai 10 ai 100 anni).
\end{itemize}
	\item Infine, le \textbf{EEPROM} (\textit{Electrically Erasable Programmable ROM}) permettono la riprogrammazione direttamente attraverso segnali elettrici, sul chip già montato nello spazio di memoria.
		Potremmo pensare che EEPROM e RAM sono effettivamente equivalente.
		Ci sono invece alcune differenze, che sono:
		\begin{itemize}
			\item L'EEPROM è persistente, mentre la RAM è volatile;
			\item Il numero di volte in cui si può riprogrammare una EEPROM è comunque limitato;
			\item Il tempo di riprogrammazione di una EEPROM è maggiore del tempo di lettura della RAM;
			\item Le tensioni che si usano nella programmazione di una EEPROM (12V-18V) sono maggiori dei 5V (o 3.3V) che richiede la RAM. 
		\end{itemize}
\end{itemize}

\subsection{Il linguaggio Verilog}
Per descrivere le reti logiche fa comodo adottare una \textbf{notazione testuale}.
Finora abbiamo usato disegni o espressioni algebriche: adesso introduciamo un \textbf{linguaggio di descrizione hardware}, il \textbf{Verilog}.
Questo linguaggio è più \textbf{compatto}, e può essere \textbf{interpretato} automaticamente da una macchina, permettendoci di effettuare prove (in modo simile a come avevamo introdotto coi diagrammi di temporizzazione).


\end{document}
