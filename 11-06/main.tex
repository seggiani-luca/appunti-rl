
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Logiche}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 06-11-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Collegamento al bus e maschere}
Resta da capire da dove vengono gli indirizzi di lettura usati nell'accesso alla SRAM.
Questi si trovano su un \textbf{bus indirizzi}, il cui valore è impostato dal processore ogni volta che vuole effettuare un accesso.
Ad esempio, per un modulo di RAM da $256 \text{M} \times 8$ bit, quindi con 28 ingressi, si avrà che bisogna di montare banchi di memoria a partire da \lstinline|0xE0000000| fino a \lstinline|0xEFFFFFFF|.

L'ingresso di select verrà quindi generato a partire dalla parte alta dell'indirizzo, fatto passare attraverso una certa maschera, facendo quindi corrispondere una certa impostazione dei bit più significativi (in questo caso 4) al segnale di select.
Visto che avevamo detto si parte da \lstinline|0xE0000000|, vogliamo \lstinline|0xE| = \lstinline|B1110|, quindi serve la rete combinatoria (maschera):
$$
\mathtt{/s} = \overline{a_{31}} + \overline{a_{30}} + \overline{a_{29}} + a_{28}
$$

Con un montaggio di questo tipo possiamo usare il select per scegliere quale banco di memoria RAM è associato a quale parte dello spazio indirizzabile.
Questo tipo di configurazione giustifica inoltre il fatto che il bit di select viene impostato con ritardo rispetto agli indirizzi: visto che deve essere calcolato sulla base di quest'ultimi, risentirà del ritardo della rete combinatoria che lo genera.

\subsection{Memorie ROM a sola lettura}
Le memorie a sola lettura, dette ROM, sono effettivamente reti combinatorie: l'uscita è costante qualunque siano gli stati passati.
Vengono montate nello spazio di memoria assieme alla RAM, e rappresentano la parte \textbf{non volatile} (persistente) dello spazio di memoria stesso (abbiamo visto come contengono le prime istruzioni eseguite dal processore).
La loro struttura interna ricalca quella della memoria RAM, privata della circuiteria necessaria alla lettura, e che usa generatori di costante al posto dei D-latch.

Una ROM può essere realizzata attraverso il MSU (\textit{Modello Strutturale Universale}), collegando in maniera ortogonale file di OR alle uscite di un decoder (come ci è concesso dall'espansione di Shannon), nei punti in cui vogliamo che un'uscita corrisponda a un certo ingresso.
Nella pratica, si usano più spesso porte NOR per ragioni elettroniche, e quindi si collegano le linee nel caso un uscita corrisponde alla negazione dell'ingresso.
Questo circuito viene solitamente stampato su un singolo chip di silicio, il cui costo fisso di progettazione è giustificato solo nel caso di produzione su larga scala.
Conviene quindi realizzare delle alternative, le \textbf{ROM programmabili}.

\subsubsection{ROM programmabili}
In una memoria ROM programmabile, le porte NOR sono tutte attaccate alle linee degli AND del decoder.
Si possono disabilitare selettivamente alcune di queste porte NOR per effettivamente \textbf{programmare} la memoria contenuta nella ROM.

Possiamo individuare delle categorie per queste reti:

\begin{itemize}
	\item Le \textbf{OTPROM} (\textit{One Time Programmable ROM}) vengono realizzate attraverso questa tecnologia, è la loro progammazione risulta quindi \textbf{distruttiva} (una volta programmato un bit non si può più rimuovere).
	\item  Una tecnologia più sofisticata è rappresentata dalle \textbf{EPROM} (\textit{Erasable programmable ROM}).
Queste vengono realizzate attraverso tranistor a field-effect.
La scrittura della EPROM può essere ripetuta sottoponendola a una luce ultravioletta, e quindi cancellando tutti i dati, per poi riscrivene altri.

Di una EPROM ci interessano:
\begin{itemize}
	\item \textbf{Endurance:} quante riscritture successive può supportare (solitamente dalle 10K alle 100K volte);
	\item \textbf{Data retention:} il periodo per cui si può fare affidamento sui dati contenuti in una EPROM (solitamente dai 10 ai 100 anni).
\end{itemize}
	\item Infine, le \textbf{EEPROM} (\textit{Electrically Erasable Programmable ROM}) permettono la riprogrammazione direttamente attraverso segnali elettrici, sul chip già montato nello spazio di memoria.
		Potremmo pensare che EEPROM e RAM sono effettivamente equivalente.
		Ci sono invece alcune differenze, che sono:
		\begin{itemize}
			\item L'EEPROM è persistente, mentre la RAM è volatile;
			\item Il numero di volte in cui si può riprogrammare una EEPROM è comunque limitato;
			\item Il tempo di riprogrammazione di una EEPROM è maggiore del tempo di lettura della RAM;
			\item Le tensioni che si usano nella programmazione di una EEPROM (12V-18V) sono maggiori dei 5V (o 3.3V) che richiede la RAM. 
		\end{itemize}
\end{itemize}

\subsection{Il linguaggio Verilog}
Per descrivere le reti logiche fa comodo adottare una \textbf{notazione testuale}.
Finora abbiamo usato disegni o espressioni algebriche: adesso introduciamo un \textbf{linguaggio di descrizione hardware}, il \textbf{Verilog}.
Questo linguaggio è più \textbf{compatto}, e può essere \textbf{interpretato} automaticamente da una macchina, permettendoci di effettuare prove (in modo simile a come avevamo introdotto coi diagrammi di temporizzazione, o addirittura con programmi come \lstinline|gtkwave| di realizzare veri e propri diagrammi di temporizzazione).

% cosa voglio sapere del verilog? 
% le basi (cos'è un modulo, cos'è un testbench, ecc...)
% BENE gli assegnamenti continui, procedurali, bloccanti, non bloccanti, ecc...

Non si riporteranno appunti riguardanti operatori e sintassi particolarmente specifiche del Verilog, in quanto esistono testi sicuramente più utili e approfonditi.
Parleremo invece della struttura di base di una sintesi in Verilog, con enfasi sugli \textbf{assegnamenti} disponibili.

\subsubsection{Struttura di una sintesi Verilog}
Il linguaggio Verilog descrive \textbf{moduli}.
Un modulo è formato da un insieme di \textbf{input} e \textbf{output}, e da una \textbf{struttura interna} che descrive la legge di evoluzione degli output in funzione degli input.
Ad esempio, il seguente frammento implementa un contatore in base 2 (che vedremo fra poco):
\begin{lstlisting}[language=verilog, style=codestyle]	
module b2_counter(eu, q, ei, clock, reset_);
  input clock, reset_;
  input ei;
  output eu, q;
  reg OUTR;
  assign q = OUTR;	
  wire a;
  assign {a, eu} = ({q, ei} == 'B00) ? 'B00:
                   ({q, ei} == 'B10) ? 'B10:
                   ({q, ei} == 'B01) ? 'B10:
                 /*({q, ei} == 'B11)*/ 'B01;
  always @(reset_ == 0) #1 OUTR <= 0;
  always @(posedge clock) if (reset_==1) #2 OUTR <= a;
endmodule
\end{lstlisting}

Si parte con la dichiarazione di un modulo \lstinline|b2_counter|, dove la sintassi "ad argomenti" indica le variabili che potremo usare come input o come output.
Definiamo poi input e output esplicitamente, notando che si può usare (e anzi è consigliata) una separazione logica delle variabili su più righe.
La parola chhiave \lstinline|reg| definisce poi un registro.

\subsubsection{Assegnamenti}
Una parte a noi particolarmente interessante del linguaggio è rappresentata dagli \textbf{assegnamenti}.
Abbiamo fatto 3 assegnamenti nelle ultime 3 istruzioni dell'esempio precedente, prima per implementare un contatore (con \lstinline|assign|), e in seguito specifcare il comportamento al reset e l'aggiornamento del registro (con \lstinline|always|).
Vediamo nel dettaglio tutte gli assegnamenti possibili e le loro differenze:
\begin{itemize}
	\item \textbf{Assegnamenti procedurali:} vengono dichiarati con \lstinline|initial| (per riferirsi a stati iniziali), o con \lstinline|always| (per riferirsi a stati qualsiasi durante la simulazione).
	In blocchi \lstinline|always|, si può specificare una condizione con il carattere \lstinline|@|, fra cui ad esempio il \lstinline|posedge| che ci permette di ricavare il positive edge di un segnale (il clock nell'esempio precedente).
	All'interno di assegnamenti procedurali abbiamo a disposizione più operatori:
	\begin{itemize}
		\item \textbf{Assegnamenti bloccanti} (=): vengono eseguiti strettamente nell'ordine in cui vengono incontrati (cosa a noi solitamente indesiderata, in quanto vogliamo modellizzare le inaccuratezze delle temporizzazioni, che non sono mai simultanee e non hanno, se non specificato, un ordine preciso);
		\item \textbf{Assegnamenti non bloccanti} (<=): vengono eseguiti in \textbf{parallelo}, cioè il valore non varia fino alla fine del blocco di assegnamento procedurale, e viene aggiornato con simultaneità al suo termine.
	\end{itemize}
\item \textbf{Assegnamenti continui:} legano \textbf{strutturalmente} una variabile ad un altra variabile, o a un costrutto \lstinline|case|, o ancora ad una sintassi ricavata dagli operatori ternari come quella nell'esempio precedente. Il valore legato viene aggiornato ad ogni aggiornamento del valore a cui è legato: vanno effettivamente intesi come fisicamente connessi.
\end{itemize}

Notiamo come negli assegnamenti in Verilog vale un concetto simile a quello di \lstinline|lvalue| e \lstinline|rvalue| nel C: si assegna sempre a \textit{sinistra}, sulla \textbf{LHS} (LeftHand Side) un valore a \textit{destra}, sulla \textbf{RHS} (RightHand Side).
Per fare un esempio, notiamo che non si può usare un \lstinline|wire| come LHS (infatti con un \lstinline|wire| ci aspetteremmo di usare una notazione strutturale, come quella data dagli assegnamenti continui).
Di contro, non si può avere aggiornamento continuo di registri (anche perché non avrebbe particolare significato logico).

Infine, notiamo che si può inserire, negli assegnamenti procedurali, un \textbf{ritardo}, indicato con il simbolo \lstinline|#| e misurato solitamente in secondi.

\end{document}
